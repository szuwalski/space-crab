
#' Build TMB object for geostatistical delta-GLMM
#'
#' \code{Build_TMB_Fn} builds a tagged list with everything necessary to run or interpret inputs for \code{MIST}
#'
#' @param TmbbData, a tagged list of data inputs generated by \code{Data_Fn}
#' @inheritParams Data_Fn
#' @param Use_REML, OPTIONAL boolean whether to use maximum marginal likelihood or restricted maximum likelihood (termed "REML")
#' @param estimate_phi, Estimate the multiplicative offset between initial and equilibrium density
#' @param Kappa, controls kappa (decorrelation distance) of spatial variation in productivity among species, as well as the spatio-temporal "process error"
#' \describe{
#'   \item{"constant"}{Same value for all spatial plus the spatio-temporal component}
#'   \item{"spatial_vs_spatiotemporal"}{Same value for all spatial, but different for the spatio-temporal component}
#'   \item{"different"}{Different for all spatial components as well as the spatio-temporal component}
#' }
#' @param Parameters OPTIONAL, a tagged list of starting parameters
#' @param Random OPTIONAL, a character vector of random effects
#' @param Map OPTIONAL, a tagged list of parameters to either mirror or turn off
#' @param Use_REML, OPTIONAL boolean whether to use maximum marginal likelihood or restricted maximum likelihood (termed "REML")
#' @param loc_x OPTIONAL, location for each sample used to generate plausible bounds for scale parameter
#' @param eigenbounds upper and lower bounds for the estimated eigenvalues of the community matrix
#' @param TmbDir OPTIONAL, a directory where the CPP file for the VAST model can be found locally
#' @param RunDir OPTIONAL, a directory where the CPP file is copied, copiled, and run (must have write privileges or else the function will crash)
#' @param silent Boolean, whether TMB should run silently

#' @return Tagged list containing objects for running a VAST model
#' \describe{
#'   \item{Obj}{The built TMB object}
#'   \item{Upper}{A vector of upper bounds for parameters, optionally for use during optimization}
#'   \item{Lower}{A vector of lower bounds for parameters, optionally for use during optimization}
#'   \item{Parameters}{A tagged list of parameter starting values used when building Obj, which can be extracted, modified, and then put back into \code{Build_TMB_Fn} to define different starting values}
#'   \item{Map}{A taggged list of parameters to be turned off or mirrored, for similar use as Parameters}
#'   \item{Random}{A character vector of random effects, for similar use as Parameters}
#' }

#' @export
Build_TMB_Fn = function( TmbData, Version, estimate_phi=TRUE, estimate_select=TRUE, Kappa="constant", Parameters="generate",
  Random="generate", Map="generate", use_REML=FALSE, loc_x=NULL, eigenbounds = c("Lower"=-2,"Upper"=-0.01), 
  TmbDir=TmbDir, RunDir ){

  # Local functions
  rmatrix = function(nrow, ncol, mean=0, sd=1, diag=NA){
    Return = matrix(rnorm(nrow*ncol,mean=mean,sd=sd), nrow=nrow, ncol=ncol)
    if( !is.na(diag)) Return[cbind(1:min(nrow,ncol),1:min(nrow,ncol))] = diag
    return(Return)
  }
  seq_pos = function( n ) seq(from=1, to=n, length=n)
  boundsifpresent_fn = function( par, map, name, lower, upper, bounds ){
    if( name %in% names(par) ){
      bounds[grep(name,names(par)),c('Lower','Upper')] = c(lower,upper)
    }
    return( bounds )
  }

  # Compile TMB software
  #dyn.unload( paste0(RunDir,"/",dynlib(TMB:::getUserDLL())) ) # random=Random,
  #file.copy( from=paste0(TmbDir,"/",Version,".cpp"), to=paste0(RunDir,"/",Version,".cpp"), overwrite=FALSE)
  setwd( RunDir )
  compile( paste0(Version,".cpp") )

  # Bounds on distances
  if( !is.null(loc_x) ){
    Dist = stats::dist(loc_x)
    MinDist = log(sqrt(8)/max(Dist)) # Range = nu*sqrt(8)/kappa
    MaxDist = log(sqrt(8)/min(Dist)) # Range = nu*sqrt(8)/kappa
    MidDist = mean( c(MinDist,MaxDist) )
  }else{
    MinDist = -Inf
    MaxDist = Inf
    MidDist = 0
  }

  # Inputs for Spatial model
  if( Version%in%c("spatial_size_8","spatial_size_9")){
    # Parameters
    
      #L_val_init = c(1,0.9,0.7,0.5,0.2,1,0.9,0.7,0.5,0.2, 1,0.9,0.7,0.5,0.9,1,0.9,0.7,0.5, 1,0.9,0.7,0.5,0.7,1,0.7,0.5, 1,0.9,0.2,0.5,0.9,1,0.9, 1,0.2,0.5,0.7,0.9,1,
      #               1,0.9,0.7,0.5,0.2, 1,0.9,0.7,0.5, 1,0.9,0.7, 1,0.9, 1)
    
      #L_val_init = ifelse( is.na(MIST:::fixdiag(Nrow=TmbData$n_p, Ncol=TmbData$n_j)), 1, 0)
      L_val_init = c(0.727,	0.225,	0.193,	0.054,	-0.03,	0.57,	0.319,	0.082,	0.035,	0.330,	0.293,	0.119,	0.174,	0.136,	0.132)
      
      if(Version%in%c("spatial_size_8")) TmbParams = list("Hinput_z"=c(0,0), "logkappa_z"=rep(MidDist,TmbData$n_p+1), "logR_mu"=rep(5,TmbData$n_t), "phi_p"=rep(5,TmbData$n_p-TmbData$n_r), "L_val"=L_val_init, "logsigma_pz"=matrix(0,nrow=TmbData$n_p,2), "logF_male_kt"=matrix(-0.6,nrow=TmbData$n_k,TmbData$n_t), "select"=c(25,0.3), "d_pkt"=array(5,dim=c(TmbData$n_p,TmbData$n_k,TmbData$n_t)), "delta_i"=rep(0,TmbData$n_i), "logF_rho"=1, "logF_mean"=0, "sigmalogF"=1)
      if (Version%in%c("spatial_size_9")) TmbParams = list("Hinput_z"=c(0,0), "logkappa_z"=rep(MidDist,TmbData$n_p+1), "logR_mu"=rep(5,TmbData$n_t), "phi_p"=rep(5,TmbData$n_p-TmbData$n_r), "L_val"=L_val_init, "logsigma_pz"=matrix(0,nrow=TmbData$n_p,2), "logF_male_kt"=matrix(-0.6,nrow=TmbData$n_k,TmbData$n_t), "select_at_size"=rep(1,TmbData$n_p), "d_pkt"=array(5,dim=c(TmbData$n_p,TmbData$n_k,TmbData$n_t)), "delta_i"=rep(0,TmbData$n_i), "logF_rho"=1, "logF_mean"=0, "sigmalogF"=1)
    # Random
    if( length(Random)==1 && Random=="generate" ){
      # Treating alpha_p, phi_p and B_pp as random (in REML) results in very slow inner optimization!  (100s of steps)
      if("logRinput_kt" %in% names(TmbParams)) Random = c( "logRinput_kt", "d_pkt" )
      if(!"logRinput_kt" %in% names(TmbParams)) Random = c( "d_pkt" )
      if( "delta_i" %in% names(TmbParams)) Random = c(Random, "delta_i", "logF_male_kt")
      
      #if( "logF_ktp" %in% names(TmbParams)) Random = c(Random, "logF_ktp")
      if(use_REML==TRUE) Random = c(Random, "logR_mu", "phi_p","L_val","select")  # , "B_pp"
    }

    # Map
    if( length(Map)==1 && Map=="generate" ){
      Map = NULL
      # Anisotropy
      Map[["Hinput_z"]] = factor( rep(NA,2) )
      # Observation model
      if(Version%in%c("spatial_size_8","spatial_size_9")) Map[["logsigma_pz"]] = matrix( 1:(2*TmbData$n_p), ncol=2, byrow=TRUE )
      
      Map[["delta_i"]] = 1:TmbData$n_i
      
      if(Version%in%c("spatial_size_8","spatial_size_9")) tmp_p =TmbData$n_p
      
      for(p in 1:tmp_p){
        if( TmbData$ObsModel_p[p]==0 ){
          Map[["logsigma_pz"]][p,] = c(NA,NA)
          if( "delta_i" %in% names(TmbParams) ) Map[["delta_i"]][which((TmbData$p_i+1)==p)] = rep(NA,sum((TmbData$p_i+1)==p))
        }
        if( TmbData$ObsModel_p[p]==1 ){
          Map[["logsigma_pz"]][p,2] = NA
          if( "delta_i" %in% names(TmbParams) ) Map[["delta_i"]][which((TmbData$p_i+1)==p)] = rep(NA,sum((TmbData$p_i+1)==p))
        }
        if( TmbData$ObsModel_p[p]==2 ){
          if( "delta_i" %in% names(TmbParams) ) Map[["delta_i"]][which((TmbData$p_i+1)==p)] = rep(NA,sum((TmbData$p_i+1)==p))
          # Check number of zeros (uses either c_i or b_i, whichever is available)
          NumZero = tapply( unlist(TmbData[c('c_i','b_i')]), INDEX=TmbData$p_i, FUN=function(vec){sum(vec==0)})
          if( any(NumZero==0) ){
            Map[["logsigma_pz"]][,2] = ifelse( NumZero==0, NA, Map[["logsigma_pz"]][,2])
            TmbParams[["logsigma_pz"]][,2] = ifelse( NumZero==0, 20, TmbParams[["logsigma_pz"]][,2])
          }
        }
        if( TmbData$ObsModel_p[p]==3 ){
          Map[["logsigma_pz"]][p,2] = NA
        }
        if( TmbData$ObsModel_p[p]==4 ){
          Map[["logsigma_pz"]][p,2] = NA
          if( "delta_i" %in% names(TmbParams) ) Map[["delta_i"]][which((TmbData$p_i+1)==p)] = rep(NA,sum((TmbData$p_i+1)==p))
        }
      }
      Map[["logsigma_pz"]] = factor( Map[["logsigma_pz"]] )
      Map[["delta_i"]] = factor( Map[["delta_i"]] )
      #Map[["logF_mean"]] = factor(Map[["logF_mean"]])
      #Map[["sigmalogF"]] = factor(Map[["sigmalogF"]])
      
      # Fix Alpha_pr and Beta_pr for the eigendecomposition method
      
      # fix phi
      if( estimate_phi==FALSE ){
        Map[["phi_p"]] = factor( rep(NA,length(TmbParams[["phi_p"]])) )
        TmbParams[["phi_p"]][] = 0
      }
      
      if( estimate_select==FALSE ){
        
        if(Version==c("spatial_size_8")) {
          Map[["select"]] = factor( rep(NA,length(TmbParams[["select"]])) )
          TmbParams[["select"]][] = c(22.4,0.32)
        }
        
        if(Version==c("spatial_size_9")) {
          Map[["select_at_size"]] = factor( rep(NA,length(TmbParams[["select_at_size"]])) )
          TmbParams[["select_at_size"]][] = c(1,1,1,1,1)
        }
        
      }
      
      Map[["logF_rho"]] = factor(NA)
      TmbParams[["logF_rho"]] = 1
      
      Map[["logF_mean"]] = factor(NA)
      TmbParams[["logF_mean"]] = 0
      
      # Fix logkappa_z at shared value by default
      if( Kappa=="constant" ){
        if("logkappa_z" %in% names(TmbParams)) Map[['logkappa_z']] = factor( rep(1,length(TmbParams[["logkappa_z"]])) )
      }
      if( Kappa=="spatial_vs_spatiotemporal" ){
        if("logkappa_z" %in% names(TmbParams)) Map[['logkappa_z']] = factor( c(rep(1,TmbData$n_t),2) )
      }
      
      # Fix logF_male_pkt for years without harvest, and change starting values to be appropriate
      if( "logF_male_kt" %in% names(TmbParams)){
      
        c_kt = matrix(0,nrow=TmbData$n_k,TmbData$n_t)
        
        for (t in 1:TmbData$n_t){
          for (k in 1:TmbData$n_k){
            c_kt[k,t] = sum(TmbData[['c_pkt']][,k,t])
          }
        }
        
          Map[["logF_male_kt"]] = matrix(1:(TmbData$n_k*TmbData$n_t),nrow=TmbData$n_k,TmbData$n_t)
          Map[["logF_male_kt"]] = ifelse( c_kt==0, NA, Map[["logF_male_kt"]] )
          Map[["logF_male_kt"]] = factor(Map[["logF_male_kt"]])
          TmbParams[["logF_male_kt"]] = ifelse( c_kt==0, -20, 0.1 )
      }
      
    }

    # Decide about user-supplied or generated Parameters
    if( length(Parameters)==1 && Parameters=="generate" ){
      Parameters = TmbParams
    }else{
      if( length(unlist(Parameters))!=length(unlist(TmbParams)) ) stop("`Parameters` input is wrong length")
    }
  } # End spatial
  
  # Build object
  dyn.load( paste0(RunDir,"/",TMB::dynlib(Version)) ) # random=Random,
  #Obj <- MakeADFun(data=TmbData, parameters=Parameters, hessian=FALSE, map=Map, random=NULL, inner.method="newton", DLL=Version)  #
  Obj <- MakeADFun(data=TmbData, parameters=Parameters, hessian=FALSE, map=Map, random=Random, inner.method="newton", DLL=Version)  #
  Obj$control <- list(trace=1, parscale=1, REPORT=1, reltol=1e-12, maxit=100)

  # Bounds
  Upper = rep(Inf, length(Obj$par) )
    
  Lower = rep(-Inf, length(Obj$par) )
    
  if("logRinput_kt" %in% names(TmbParams)) Lower[grep("logMargSigmaR",names(Obj$par))] = log(0.01)
  Lower[grep("R_mu",names(Obj$par))] = log(1)
  Lower[grep("phi_p",names(Obj$par))] = log(1)
  
  if(Version%in%c("spatial_size_8")){
    Lower[grep("select",names(Obj$par))] = 0
    Upper[grep("select",names(Obj$par))] = 100
  }else{
    Lower[grep("select_at_size",names(Obj$par))] = 0
    Upper[grep("select_at_size",names(Obj$par))] = 1
  }

  # Bounds on distances
  if( length(grep("logkappa",names(Obj$par)))>0 && !is.na(TmbData$Options_vec['Spatial_Method']) && TmbData$Options_vec['Spatial_Method']==0 ){
    Lower[grep("logkappa",names(Obj$par))] = MinDist # Range = nu*sqrt(8)/kappa
    Upper[grep("logkappa",names(Obj$par))] = MaxDist # Range = nu*sqrt(8)/kappa
  }

  # Change convergence tolerance
  #Obj$env$inner.control$step.tol <- c(1e-8,1e-12,1e-15)[ConvergeTol] # Default : 1e-8  # Change in parameters limit inner optimization
  #Obj$env$inner.control$tol10 <- c(1e-6,1e-8,1e-12)[ConvergeTol]  # Default : 1e-3     # Change in pen.like limit inner optimization
  #Obj$env$inner.control$grad.tol <- c(1e-8,1e-12,1e-15)[ConvergeTol] # # Default : 1e-8  # Maximum gradient limit inner optimization

  # Print number of parameters
  message("Number of fixed and random effects:")
  print( table(names(Obj$env$last.par)) )

  # Return stuff
  Return = list("Obj"=Obj, "Upper"=Upper, "Lower"=Lower, "Parameters"=Parameters, "Map"=Map, "Random"=Random )
  return(Return)
}
